{% load static %}

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <link rel="shortcut icon" href="{% static 'authentification/LogoTest1.png' %}" type="image/x-icon">
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.7.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.7.0/mapbox-gl.css' rel='stylesheet' />
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.2.0/mapbox-gl-draw.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.2.0/mapbox-gl-draw.css"
        rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/geotiff"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>

    <style>

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            flex-direction: column;
            font-family: Georgia, 'Times New Roman', Times, serif;
            color: #00ffc8;
            height: 100vh;
            width: 100vw;
        }
        
        header {
            background-color: rgba(0, 0, 0, 0.8);
            transition: 0.3s ease-in-out;
            padding: 1rem 0;
            z-index: 1000;
            position: relative;
        }
        
        header:hover {
            background-color: rgba(20, 20, 20, 1);
        }
        
        .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 98%;
            margin: 0 auto;
        }
        
        .logo h1 {
            font-style: italic;
            font-size: 1.5rem;
        }
        
        .logo span {
            font-style: italic;
        }
        
        #map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        
        .mapboxgl-ctrl-scale {
            background-color: transparent;
            display: flex;
            position: absolute;
            bottom: 450%;
            left: 1270px;
            justify-content: flex-end;
            align-items: center;
            height: 10px;
        }
        
        .mapboxgl-ctrl a,
        .mapboxgl-ctrl-attrib-inner {
            display: none;
        }
        
        .mapboxgl-ctrl-top-right {
            position: absolute;
            top: 555px;
            right: 85px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: transparent;
        }
        
        .mapboxgl-ctrl-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .elements-container {
            position: absolute;
            left: -350px;
            top: 60px;
            bottom: 50px;
            width: 350px;
            transition: left 0.5s ease-in-out;
            z-index: 900;
        }
        
        .elements {
            width: 100%;
            height: 100%;
            background-color: rgba(20, 20, 20, 1);
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            color: #00ffc8;
            overflow-y: auto;
        }
        
        .btn {
            background-color: transparent;
            border: 1px solid #00ffc8;
            color: #00ffc8;
            padding: 10px 15px;
            margin-bottom: 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: flex-start;
        }
        
        .btn:hover {
            background-color: #00ffc8;
            color: rgba(20, 20, 20, 1);
        }
        
        .btn i {
            margin-right: 10px;
            font-size: 1.2em;
        }
        
        #toggle-actions {
            position: absolute;
            right: 0;
            background: transparent;
            border: none;
            cursor: pointer;
            margin: 5px;
        }
        
        #toggle-actions i {
            font-size: 2em;
            color: #00ffc8;
        }
        
        #showElement {
            position: absolute;
            right: -25px;
            top: 50%;
            transform: translateY(-50%);
            width: 25px;
            height: 55px;
            background-color: rgba(20, 20, 20, 1);
            border: none;
            border-radius: 0 15px 15px 0;
            cursor: pointer;
            color: #00ffc8;
            font-size: 20px;
            transition: 0.3s ease-in-out;
            z-index: 901;
        }
        
        #showAction {
            position: absolute;
            left: -25px;
            top: 43%;
            transform: translateY(50%);
            width: 25px;
            height: 55px;
            background-color: rgba(20, 20, 20, 1);
            border: none;
            border-radius: 15px 0 0 15px;
            cursor: pointer;
            color: #00ffc8;
            font-size: 20px;
            transition: 0.3s ease-in-out;
            z-index: 901;
        }
        
        #showElement:hover {
            background-color: rgba(40, 40, 40, 1);
        }
        
        #showElement:focus {
            outline: none;
        }
        
        #rasterCheckboxes {
            height: 50%;
            display: flex;
            flex-direction: column;
            border-bottom: solid 1px rgba(40, 40, 40, 0.9);
        }
        
        .actions-container {
            position: fixed;
            background-color: rgba(20, 20, 20, 0.9);
            right: -350px;
            top: 77px;
            bottom: 87px;
            width: 350px;
            transition: right 0.5s ease-in-out;
            z-index: 900;
        }
        
        .action {
            width: 100%;
            height: 100%;
            background-color: rgba(20, 20, 20, 1);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            color: #00ffc8;
            overflow-y: auto;
        }
        
        .action>div {
            flex: 1;
        }
        
        footer {
            background-color: rgba(0, 0, 0, 0.8);
            padding: 1rem 0;
            transition: 0.3s ease-in-out;
            position: relative;
            margin-top: auto;
            z-index: 1000;
        }
        
        .foothead {
            background-color: rgba(20, 20, 20, 1);
        }
        
        footer:hover {
            background-color: rgba(20, 20, 20, 1);
        }
        
        select {
            background-color: rgba(20, 20, 20, 1);
            color: #00ffc8;
            border: 1px solid #00ffc8;
            padding: 5px;
            border-radius: 5px;
        }
        
        .user-menu summary {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #00ffc8;
            cursor: pointer;
        }
        
        .user-menu ul {
            position: absolute;
            right: 0;
            bottom: -105px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(0, 255, 200, 0.3);
            border-top: none !important;
            border-radius: 0 0 0 8px;
            padding: 0.5rem;
            transition: 0.3s ease-in-out;
            margin-top: 0.5rem;
        }
        
        .user-menu ul:hover {
            background-color: rgba(20, 20, 20, 1);
        }
        
        .user-menu li {
            padding: 0.5rem 1rem;
            list-style: none;
        }
        
        .user-menu li:hover {
            background-color: rgba(0, 255, 200, 0.2);
        }
        
        .user-menu a {
            color: #00ffc8;
            text-decoration: none;
            display: block;
            padding: 5px 0;
            list-style: none;
        }
        
        #rasterCheckboxes {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            border-bottom: solid 1px rgba(40, 40, 40, 0.9);
        }
        
        #rasterCheckboxes div {
            margin-bottom: 10px;
        }
        
        #rasterCheckboxes input[type="checkbox"] {
            margin-right: 10px;
        }
        
        #geojsonCheckboxes {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            border-bottom: solid 1px rgba(40, 40, 40, 0.9);
        }
        
        #geojsonCheckboxes div {
            margin-bottom: 10px;
        }
        
        #geojsonCheckboxes input[type="checkbox"] {
            margin-right: 10px;
        }
        
        #divextract {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 10px;
        }
        
        /* Style général pour les inputs */
        input[type="text"],
        input[type="number"] {
            background-color: rgba(20, 20, 20, 1);
            color: #00ffc8;
            border: 1px solid #00ffc8;
            padding: 5px;
            border-radius: 5px;
        }
        
        /* Style au focus */
        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(0, 255, 200, 0.3);
        }
        
        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .logo img {
            width: 45px;
            border-radius: 50%;
        }
        
        /* Style pour le placeholder */
        input::placeholder {
            color: rgba(0, 255, 200, 0.5);
        }
        
        /* Style pour les labels */
        #divextract label {
            color: #00ffc8;
            margin-bottom: 5px;
            gap: 10px;
        }
        
        .custom-marker {
            background-color: rgba(0, 0, 0, 0.6);
            color: #00ffc8;
            padding: 5px;
            border-radius: 3px;
            font-family: Arial, sans-serif;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
        }

    </style>
</head>

<body>

    <header id="header">

        <div class="container">

            <div class="logo">

                <img src="{% static 'authentification/LogoTest1.png' %}" alt="">
                <h1>IDoGek</h1>

            </div>

            <div class="map-control">

                <label for="style-selector"><i class="bi bi-layers"></i> Style de carte:</label>
                <select id="style-selector">
                    <option value="streets-v12">OpenStreetMap</option>
                    <option value="satellite-streets-v12">GoogleEarth</option>
                </select>

            </div>

            <div class="profil">

                <nav class="user-menu">
                    <details>
                        <summary>
                            <i class="bi bi-person-circle"></i>
                            <span> {{user.username}} </span>
                        </summary>
                        <ul>
                            <li>
                                <a href="{% url 'igogek:profil' %}"><i class="bi bi-person"></i> Profil</a>
                            </li>
                            <li>
                                <a href="{% url 'authentification:logout' %}">
                                    <i class="bi bi-box-arrow-right"></i>
                                    Déconnexion
                                </a>
                            </li>
                        </ul>
                    </details>
                </nav>

            </div>

        </div>

    </header>

    <main>

        <div id="map"></div>

        <div class="elements-container">

            <div class="elements">

                <button id="resetBtn" class="btn"><i class="bi bi-trash"></i> Réinitialiser</button>
                <button id="centerBtn" class="btn"><i class="bi bi-geo"></i> Centrer sur Kribi</button>
                <button id="downloadBtn" class="btn"><i class="bi bi-upload"></i> Exporter un GeoJSON</button>
                <button id="uploadBtn" class="btn"><i class="bi bi-download"></i> Charger un Raster</button>
                <button id="importBtn" class="btn"><i class="bi bi-filetype-json"></i> Importer un GeoJSON</button>

            </div>
            <button id="showElement" class="showElement"><i class="bi bi-caret-right"></i></button>

        </div>

        <div class="actions-container">

            <button id="toggle-actions"><i class="bi bi-x-circle"></i></button>
            <h1>Elements importés</h1>

            <div class="action" id="raster">

                <div id="rasterCheckboxes">

                    <h2>Rasters</h2>

                </div>

                <div id="geojsonCheckboxes">

                    <h2>GeoJSON</h2>

                </div>

                <div id="divextract">
                    <h2>Extraire carte</h2>
                    <div class="map-control">
                        <label for="format">Format de sortie:</label>
                        <select id="format">
                            <option value="png">PNG</option>
                            <option value="jpg">JPG</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="width">Largeur (px):</label>
                        <input type="number" id="width" value="1280" min="1" max="3840" />
                    </div>
                    <div class="control-group">
                        <label for="height">Hauteur (px):</label>
                        <input type="number" id="height" value="1280" min="1" max="2160" />
                    </div>
                    <label for="filename">Nom du fichier: <input type="text" placeholder="Entrer le nom du fichier"
                            value="mapbox-extract" id="filename" /></label>
                    <button id="actionextract" class="btn">Extraire la zone sélectionnée</button>
                </div>

            </div>
            <button id="showAction" class="showAction"><i class="bi bi-plus"></i></button>

        </div>

    </main>

    <footer id="footer">

        <div class="container">
            <div class="logo">
                <span>IDoGeK</span>
            </div>

            <p>&copy; 2024 IDoGeK</p>
        </div>

    </footer>

    <script>

        mapboxgl.accessToken = 'pk.eyJ1IjoiY2VkcmljZXBhZGllIiwiYSI6ImNtMXE3aTRsNDBibTAycG9qajR5YjFjdm4ifQ.uMkRry3szVbv-cKeqJDBtg'

        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/streets-v12',
            center: [9.9106, 2.9397],
            zoom: 13
        })

        function addTouchEventListeners(map) {
            const container = map.getContainer();

            const preventDefault = (e) => {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            };

            const options = { passive: false };

            container.addEventListener('touchstart', preventDefault, options);
            container.addEventListener('touchmove', preventDefault, options);
            container.addEventListener('touchend', preventDefault, options);
        }

        // Appelez cette fonction après avoir initialisé votre carte
        addTouchEventListeners(map);

        // Ajouter l'échelle
        const scale = new mapboxgl.ScaleControl({
            maxWidth: 80, // Largeur maximale de l'échelle (en pixels)
            unit: 'metric' // 'metric' pour le système métrique, 'imperial' pour le système impérial
        })

        map.addControl(scale);

        const nav = new mapboxgl.NavigationControl();
        map.addControl(nav);

        const draw = new MapboxDraw({
            displayControlsDefault: false,
            controls: {
                point: true,
                line_string: true,
                polygon: true,
                trash: true
            }
        });
        map.addControl(draw);

        // Mettre à jour l'échelle en fonction du zoom et du déplacement de la carte
        map.on('load', () => {
            scale.setUnit('metric'); // Vous pouvez choisir 'imperial' si vous voulez des miles
        });

        // Dictionnaire de toutes les couches chargées
        let loadedLayers = {}

        // Bouton de réinitialisation
        document.getElementById('resetBtn').addEventListener('click', function () {
            window.location.href = window.location.href;
        })

        // Bouton de recentrage
        document.getElementById('centerBtn').addEventListener('click', function () {
            map.flyTo({ center: [9.9106, 2.9397], zoom: 13 })
        })

        // Fonction pour télécharger le GeoJSON
        function downloadGeoJSON() {
            // Récupérer les features des couches déjà chargées en utilisant getGeoJsonForLayers
            const loadedLayersGeoJSON = getGeoJsonForLayers(loadedLayers)
            const loadedLayersFeatures = loadedLayersGeoJSON.features || []

            // Récupérer les features dessinées
            const drawnFeatures = draw.getAll().features

            // Combiner toutes les features
            const allFeatures = [...loadedLayersFeatures, ...drawnFeatures]

            if (allFeatures.length === 0) {
                alert('Impossible! Aucun élément à télécharger. Veuillez charger des couches ou dessiner des éléments.')
                return
            }

            // Créer l'objet GeoJSON final
            const geoJSON = {
                type: 'FeatureCollection',
                features: allFeatures
            }

            // Convertir en chaîne JSON
            const geoJSONString = JSON.stringify(geoJSON, null, 2)

            // Créer un Blob
            const blob = new Blob([geoJSONString], { type: 'application/json' })

            // Créer un lien de téléchargement
            const url = URL.createObjectURL(blob)
            const a = document.createElement('a')
            a.href = url
            a.download = 'map_data.geojson'

            // Déclencher le téléchargement
            document.body.appendChild(a)
            a.click()

            // Nettoyer
            document.body.removeChild(a)
            URL.revokeObjectURL(url)
        }

        // Fonction pour recuperer les couches importé
        function getGeoJsonForLayers(loadedLayers) {
            let combinedFeatures = []

            // Parcourir toutes les couches chargées
            for (const layerId in loadedLayers) {
                if (loadedLayers.hasOwnProperty(layerId)) {
                    const source = map.getSource(layerId)

                    if (source && source.type === 'geojson') {
                        const data = source._data // Récupérer les données GeoJSON de la source
                        if (data && data.features) {
                            combinedFeatures = combinedFeatures.concat(data.features) // Combiner les features
                        }
                    }
                }
            }

            // Construire un objet GeoJSON combiné
            return {
                type: 'FeatureCollection',
                features: combinedFeatures
            }
        }

        // Ajouter l'écouteur d'événements au bouton de téléchargement
        document.getElementById('downloadBtn').addEventListener('click', downloadGeoJSON)

        // Gestion de la div coulissante
        const elementsContainer = document.querySelector('.elements-container');
        const showElementBtn = document.getElementById('showElement');
        const header = document.getElementById('header');
        const footer = document.getElementById('footer');
        const ScaleControl = document.querySelector('.mapboxgl-ctrl-scale');
        const top_rigt = document.querySelector('.mapboxgl-ctrl-top-right');
        let isOpen = false;

        showElementBtn.addEventListener('click', () => {
            if (isOpen) {
                elementsContainer.style.left = '-350px';
                showElementBtn.innerHTML = '<i class="bi bi-caret-right-fill"></i>';
                header.classList.remove('foothead');
                footer.classList.remove('foothead');
            } else {
                elementsContainer.style.left = '0';
                showElementBtn.innerHTML = '<i class="bi bi-caret-left-fill"></i>';
                header.classList.add('foothead');
                footer.classList.add('foothead');
            }
            isOpen = !isOpen;
        });

        const actionsContainer = document.querySelector('.actions-container');
        document.getElementById('uploadBtn').addEventListener('click', () => {
            actionsContainer.style.right = '0';
        })

        document.getElementById('showAction').addEventListener('click', () => {
            actionsContainer.style.right = '0';

        })

        document.getElementById('toggle-actions').addEventListener('click', () => {
            actionsContainer.style.right = '-350px';
        })

        let rasters = [];

        document.getElementById('uploadBtn').addEventListener('click', function () {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = true;
            input.accept = '.tif,.tiff';
            input.onchange = handleFileSelectRaster;
            input.click();
        });

        function handleFileSelectRaster(event) {
            const files = event.target.files;
            for (let file of files) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const arrayBuffer = e.target.result;
                    parseGeoTIFF(arrayBuffer, file.name);
                };
                reader.readAsArrayBuffer(file);
            }
        }

        function addLayerForGeometryType(sourceId, type, geometryType, color) {
            const layerId = `${sourceId}-${type}`;
            const layerConfig = {
                id: layerId,
                type: type,
                source: sourceId,
                paint: {},
                filter: ['==', '$type', geometryType]
            };

            switch (type) {
                case 'fill':
                    layerConfig.paint['fill-color'] = color;
                    layerConfig.paint['fill-opacity'] = 0.8;
                    break;
                case 'line':
                    layerConfig.paint['line-color'] = color;
                    layerConfig.paint['line-width'] = 2;
                    break;
                case 'circle':
                    layerConfig.paint['circle-color'] = color;
                    layerConfig.paint['circle-radius'] = 5;
                    break;
            }

            map.addLayer(layerConfig);
        }

        function getBounds(geojson) {
            const bounds = new mapboxgl.LngLatBounds();
            let hasValidCoordinates = false;

            function isValidCoordinate(coord) {
                return Array.isArray(coord) &&
                    coord.length >= 2 &&
                    typeof coord[0] === 'number' &&
                    typeof coord[1] === 'number' &&
                    coord[0] >= -180 && coord[0] <= 180 &&
                    coord[1] >= -90 && coord[1] <= 90;
            }

            function extendBounds(coords) {
                if (Array.isArray(coords[0])) {
                    coords.forEach(extendBounds);
                } else if (isValidCoordinate(coords)) {
                    bounds.extend(coords);
                    hasValidCoordinates = true;
                } else {
                    hasValidCoordinates = false;
                }
            }

            if (geojson.type === 'FeatureCollection') {
                geojson.features.forEach(feature => {
                    if (feature.geometry && feature.geometry.coordinates) {
                        extendBounds(feature.geometry.coordinates);
                    }
                });
            } else if (geojson.type === 'Feature' && geojson.geometry && geojson.geometry.coordinates) {
                extendBounds(geojson.geometry.coordinates);
            }

            return hasValidCoordinates ? bounds : null;
        }

        // Fonction pour générer une couleur aléatoire
        function getRandomColor() {
            const r = Math.floor(Math.random() * 256);
            const g = Math.floor(Math.random() * 256);
            const b = Math.floor(Math.random() * 256);
            return `rgb(${r},${g},${b})`;
        }

        async function parseGeoTIFF(arrayBuffer, fileName) {
            const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
            const image = await tiff.getImage();
            const bbox = image.getBoundingBox();
            const rasterData = await image.readRasters();

            const raster = {
                id: 'raster-' + Date.now(),
                name: fileName,
                bounds: bbox,
                data: rasterData[0],
                width: image.getWidth(),
                height: image.getHeight()
            };

            const pngDataUrl = await convertToPNG(raster);
            raster.pngDataUrl = pngDataUrl;

            rasters.push(raster);
            addRasterToMap(raster);
            createCheckboxRaster(raster);
        }

        // Fonction pour convertir un tif en png
        async function convertToPNG(raster) {
            const canvas = document.createElement('canvas');
            canvas.width = raster.width;
            canvas.height = raster.height;
            const ctx = canvas.getContext('2d');

            // Créer une ImageData à partir des données raster
            const imageData = ctx.createImageData(raster.width, raster.height);

            // Convertir les données en niveaux de gris en RVBA
            for (let i = 0; i < raster.data.length; i++) {
                const val = raster.data[i];
                imageData.data[i * 4] = val;     // R
                imageData.data[i * 4 + 1] = val; // V
                imageData.data[i * 4 + 2] = val; // B
                imageData.data[i * 4 + 3] = 255; // A (opaque)
            }

            // Dessiner l'ImageData sur le canvas
            ctx.putImageData(imageData, 0, 0);

            // Convertir le canvas en PNG (Data URL)
            return canvas.toDataURL('image/png');
        }

        function addRasterToMap(raster) {
            map.addSource(raster.id, {
                type: 'image',
                url: raster.pngDataUrl,
                coordinates: [
                    [raster.bounds[0], raster.bounds[3]],
                    [raster.bounds[2], raster.bounds[3]],
                    [raster.bounds[2], raster.bounds[1]],
                    [raster.bounds[0], raster.bounds[1]]
                ]
            });

            map.addLayer({
                id: raster.id,
                type: 'raster',
                source: raster.id,
                paint: {
                    'raster-opacity': 0.7
                }
            });
            map.fitBounds(raster.bounds, { padding: 20 })
        }

        // Fonction pour créer les checkbox pour activer et désactiver les raster
        function createCheckboxRaster(raster) {
            const container = document.getElementById('rasterCheckboxes');
            const div = document.createElement('div');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = raster.id + '-checkbox';
            checkbox.checked = true;

            const label = document.createElement('label');
            label.htmlFor = checkbox.id;
            label.textContent = raster.name;

            checkbox.addEventListener('change', function () {
                const visibility = this.checked ? 'visible' : 'none';
                map.setLayoutProperty(raster.id, 'visibility', visibility);
            });

            div.appendChild(checkbox);
            div.appendChild(label);
            container.appendChild(div);
        }

        function createCheckboxGeojson(layer) {
            const container = document.getElementById('geojsonCheckboxes');
            const div = document.createElement('div');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = layer.id + '-checkbox';
            checkbox.checked = true;

            const label = document.createElement('label');
            label.htmlFor = checkbox.id;
            label.textContent = layer.name;

            checkbox.addEventListener('change', function () {
                const visibility = this.checked ? 'visible' : 'none';
                ['fill', 'line', 'circle'].forEach(type => {
                    const layerId = `${layer.id}-${type}`;
                    if (map.getLayer(layerId)) {
                        map.setLayoutProperty(layerId, 'visibility', visibility);
                    }
                });
            });

            div.appendChild(checkbox);
            div.appendChild(label);
            container.appendChild(div);
        }

        function shortenGeoJSON(geojson, precision = 10) {
            function roundCoord(coord) {
                return parseFloat(coord.toFixed(precision));
            }
        
            function processCoordinates(coords) {
                if (typeof coords[0] === 'number') {
                    return coords.map(roundCoord);
                }
                return coords.map(processCoordinates);
            }
        
            function processGeometry(geometry) {
                return {
                    ...geometry,
                    coordinates: processCoordinates(geometry.coordinates)
                };
            }
        
            return {
                type: 'FeatureCollection',
                features: geojson.features.map(feature => ({
                    ...feature,
                    geometry: processGeometry(feature.geometry)
                }))
            };
        }
        
        document.getElementById('actionextract').addEventListener('click', async function () {
            const features = draw.getAll()
            if (features.features.length === 0) {
                alert("Veuillez d'abord dessiner une zone sur la carte.")
                return
            }

            const bbox = turf.bbox(features.features[0])
            const format = document.getElementById('format').value
            const width = document.getElementById('width').value
            const height = document.getElementById('height').value
            const name = document.getElementById('filename').value

            const lngLatCenter = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2]
            const zoom = map.getZoom()
            console.log(loadedLayers)
            // Construire l'URL d'API statique
            const combinedGeoJson = getGeoJsonForLayers(loadedLayers);
            combinedGeoJson.features.forEach((feature) => {
                feature.properties = feature.properties || {}
                feature.properties['stroke'] = '#FF0000' // Couleur rouge pour les lignes
                feature.properties['stroke-width'] = 2 // Épaisseur des lignes
                feature.properties['fill'] = '#FF0000' // Couleur rouge pour le remplissage
                feature.properties['fill-opacity'] = 0.5 // Transparence du remplissage
            })
            const shortenedGeoJson = shortenGeoJSON(combinedGeoJson);
            const geojsonFeatures = encodeURIComponent(JSON.stringify(shortenedGeoJson));
            const url = `https://api.mapbox.com/styles/v1/mapbox/satellite-streets-v12/static/geojson(${geojsonFeatures})/${lngLatCenter[0]},${lngLatCenter[1]},${zoom}/${width}x${height}@2x?access_token=${mapboxgl.accessToken}`

            try {
                const response = await fetch(url)
                const blob = await response.blob()
                const link = document.createElement('a')
                link.href = URL.createObjectURL(blob)
                link.download = `${name}.${format}`
                document.body.appendChild(link)
                link.click()
                document.body.removeChild(link)
            } catch (error) {
                console.error("Erreur lors du téléchargement de l'image:", error)
                alert("Une erreur est survenue lors de l'extraction de l'image.")
            }
        })

        // Ajout des styles CSS
        const style = document.createElement('style');
        style.textContent = `
.metadata-button, .download-button {
    background-color: #00ffc8;
    color: rgba(20, 20, 20, 1);
    border: none;
    padding: 5px 10px;
    margin: 5px;
    cursor: pointer;
    border-radius: 3px;
}

.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow-x: auto;
    background-color: rgba(0,0,0,0.4);
}

.modal-content {
    background-color: rgba(20, 20, 20, 1);
    margin: 15% auto;
    padding: 20px;
    border: 1px solid #00ffc8;
    width: 80%;
    color: #00ffc8;
    overflow-x: auto;
    overflow-y: auto;
}

.close {
    color: #00ffc8;
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
}

th, td {
    border: 1px solid #00ffc8;
    padding: 10px;
    text-align: left;
}

th {
    background-color: rgba(0, 255, 200, 0.2);
}
`;
        document.head.appendChild(style);

        let geojsonLayers = [];

        document.getElementById('importBtn').addEventListener('click', function () {
            actionsContainer.style.right = '0';
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = true;
            input.accept = '.geojson,.json';
            input.onchange = handleFileSelect;
            input.click();
        });

        function handleFileSelect(event) {
            const files = event.target.files;
            for (let file of files) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const geojson = JSON.parse(e.target.result);
                        addGeoJSONToMap(geojson, file.name);
                    } catch (error) {
                        console.error("Erreur lors du chargement du fichier:", file.name, error);
                        alert(`Erreur lors du chargement du fichier ${file.name}: ${error.message}`);
                    }
                };
                reader.readAsText(file);
            }
        }

        function addGeoJSONToMap(geojson, fileName) {
            const layerId = 'geojson-' + Date.now();

            map.addSource(layerId, {
                type: 'geojson',
                data: geojson
            });

            addLayerForGeometryType(layerId, 'fill', 'Polygon', getRandomColor());
            addLayerForGeometryType(layerId, 'line', 'LineString', getRandomColor());
            addLayerForGeometryType(layerId, 'circle', 'Point', getRandomColor());

            const bounds = getBounds(geojson);
            if (bounds) {
                map.fitBounds(bounds, { padding: 50 });
            } else {
                alert("Impossible de déterminer les limites du GeoJSON");
            }

            geojsonLayers.push({ id: layerId, name: fileName, geojson: geojson }); // Sauvegarde le GeoJSON
            loadedLayers[layerId] = geojson;
            createCheckbox({ id: layerId, name: fileName });
        }

        function addLayerForGeometryType(sourceId, type, geometryType, color) {
            const layerId = `${sourceId}-${type}`;
            map.addLayer({
                id: layerId,
                type: type,
                source: sourceId,
                paint: type === 'fill' ? {
                    'fill-color': color,
                    'fill-opacity': 0.8
                } : type === 'line' ? {
                    'line-color': color,
                    'line-width': 2
                } : {
                    'circle-color': color,
                    'circle-radius': 5
                },
                filter: ['==', '$type', geometryType]
            });
        }

        function getBounds(geojson) {
            const bounds = new mapboxgl.LngLatBounds();
            let hasValidCoordinates = false;

            function isValidCoordinate(coord) {
                return Array.isArray(coord) &&
                    coord.length >= 2 &&
                    typeof coord[0] === 'number' &&
                    typeof coord[1] === 'number' &&
                    coord[0] >= -180 && coord[0] <= 180 &&
                    coord[1] >= -90 && coord[1] <= 90;
            }

            function extendBounds(coords) {
                if (Array.isArray(coords[0])) {
                    coords.forEach(extendBounds);
                } else if (isValidCoordinate(coords)) {
                    bounds.extend(coords);
                    hasValidCoordinates = true;
                }
            }

            if (geojson.type === 'FeatureCollection') {
                geojson.features.forEach(feature => {
                    if (feature.geometry && feature.geometry.coordinates) {
                        extendBounds(feature.geometry.coordinates);
                    }
                });
            } else if (geojson.type === 'Feature' && geojson.geometry && geojson.geometry.coordinates) {
                extendBounds(geojson.geometry.coordinates);
            }

            return hasValidCoordinates ? bounds : null;
        }

        function createCheckbox(layer) {
            const container = document.getElementById('geojsonCheckboxes');
            const div = document.createElement('div');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = layer.id + '-checkbox';
            checkbox.checked = true;

            const label = document.createElement('label');
            label.htmlFor = checkbox.id;
            label.textContent = layer.name;

            const metadataButton = document.createElement('button');
            metadataButton.textContent = 'Métadonnées';
            metadataButton.className = 'metadata-button';
            metadataButton.onclick = function () {
                displayMetadata(layer.id);
            };

            checkbox.addEventListener('change', function () {
                const visibility = this.checked ? 'visible' : 'none';
                ['fill', 'line', 'circle'].forEach(type => {
                    const layerId = `${layer.id}-${type}`;
                    if (map.getLayer(layerId)) {
                        map.setLayoutProperty(layerId, 'visibility', visibility);
                    }
                });
            });

            div.appendChild(checkbox);
            div.appendChild(label);
            div.appendChild(metadataButton);
            container.appendChild(div);
        }

        // Ajoutez cet écouteur pour recharger les couches GeoJSON après un changement de style
        map.on('style.load', function () {
            geojsonLayers.forEach(layer => {
                // Réappliquez la source et les couches après un changement de style
                map.addSource(layer.id, {
                    type: 'geojson',
                    data: layer.geojson
                });

                addLayerForGeometryType(layer.id, 'fill', 'Polygon', getRandomColor());
                addLayerForGeometryType(layer.id, 'line', 'LineString', getRandomColor());
                addLayerForGeometryType(layer.id, 'circle', 'Point', getRandomColor());
            });
            map.flyTo({ center: [9.9106, 2.9397], zoom: 13 })
        });


        function createModal() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
        <div class="modal-content">
            <span class="close">&times;</span>
            <div id="metadata-content"></div>
            <button id="downloadBtn" class="download-button">Télécharger le tableau</button>
        </div>
    `;
            document.body.appendChild(modal);

            const closeBtn = modal.querySelector('.close');
            closeBtn.onclick = function () {
                modal.style.display = "none";
            }

            window.onclick = function (event) {
                if (event.target == modal) {
                    modal.style.display = "none";
                }
            }

            const downloadBtn = modal.querySelector('#downloadBtn');
            downloadBtn.onclick = function () {
                downloadTableAsCSV();
            }

            return modal;
        }

        const modal = createModal();

        function displayMetadata(layerId) {
            const source = map.getSource(layerId);
            if (source && source._data) {
                let features = [];
                if (source._data.type === 'FeatureCollection') {
                    features = source._data.features;
                } else if (source._data.type === 'Feature') {
                    features = [source._data];
                }

                const metadataContent = document.getElementById('metadata-content');
                metadataContent.innerHTML = ''; // Effacer le contenu précédent

                if (features.length === 0) {
                    metadataContent.innerHTML = 'Aucune fonctionnalité à afficher.';
                    modal.style.display = "block";
                    return;
                }

                let tableHTML = '<table id="metadataTable">';
                tableHTML += '<thead><tr><th>Feature</th>';

                const firstFeature = features[0].properties;
                const keys = Object.keys(firstFeature);
                keys.forEach((key) => {
                    tableHTML += `<th>${key}</th>`;
                });

                tableHTML += '</tr></thead><tbody>';
                features.forEach((feature, index) => {
                    const props = feature.properties;
                    let rowHTML = `<tr><td>Feature ${index + 1}</td>`;
                    keys.forEach((key) => {
                        rowHTML += `<td>${props[key] !== undefined ? props[key] : ''}</td>`;
                    });
                    rowHTML += '</tr>';
                    tableHTML += rowHTML;
                });

                tableHTML += '</tbody></table>';
                metadataContent.innerHTML = tableHTML;
                modal.style.display = "block";
            }
        }

        function downloadTableAsCSV() {
            const table = document.getElementById('metadataTable');
            let csv = [];
            for (let i = 0; i < table.rows.length; i++) {
                let row = [], cols = table.rows[i].cells;
                for (let j = 0; j < cols.length; j++) {
                    row.push(cols[j].innerText);
                }
                csv.push(row.join(','));
            }
            const csvString = csv.join('\n');
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", "metadata.csv");
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        const markers = new Map();

        function updateMarker(id, coordinates, content) {
            let marker = markers.get(id);
            if (marker) {
                marker.setLngLat(coordinates);
                marker.getElement().innerHTML = content;
            } else {
                const el = document.createElement('div');
                el.className = 'custom-marker';
                el.innerHTML = content;
                marker = new mapboxgl.Marker(el)
                    .setLngLat(coordinates)
                    .addTo(map);
                markers.set(id, marker);
            }
        }

        function calculateLineLength(coordinates) {
            return turf.length(turf.lineString(coordinates)).toFixed(2);
        }

        function calculatePolygonMetrics(coordinates) {
            const polygon = turf.polygon([coordinates]);
            const area = turf.area(polygon);
            const perimeter = turf.length(turf.lineString(coordinates));
            return {
                area: (area / 1000000).toFixed(2),  // Conversion en km²
                perimeter: (perimeter)  // Conversion en km
            };
        }

        function handleFeature(feature) {
            let content, coordinates;

            switch (feature.geometry.type) {
                case 'Point':
                    coordinates = feature.geometry.coordinates;
                    content = `Coordonnées : ${coordinates[0].toFixed(4)}, ${coordinates[1].toFixed(4)}`;
                    updateMarker(feature.id, coordinates, content);
                    break;
                case 'LineString':
                    coordinates = feature.geometry.coordinates;
                    const length = calculateLineLength(coordinates);
                    content = `Longueur : ${length} km`;
                    updateMarker(feature.id, turf.center(feature).geometry.coordinates, content);
                    break;
                case 'Polygon':
                    coordinates = feature.geometry.coordinates[0];
                    const metrics = calculatePolygonMetrics(coordinates);
                    content = `Périmètre : ${metrics.perimeter} m<br>Surface : ${metrics.area} km²`;
                    updateMarker(feature.id, turf.center(feature).geometry.coordinates, content);
                    break;
            }
        }

        map.on('style.load', () => {
            rasters.forEach(raster => {
                addRasterToMap(raster)
            });
            map.flyTo({ center: [9.9106, 2.9397], zoom: 13 })
        })

        // Modifiez la fonction de changement de style
        function changeMapStyle(style) {
            map.setStyle(`mapbox://styles/mapbox/${style}`)
        }

        // Assurez-vous que cette fonction est appelée lorsque l'utilisateur change le style de la carte
        document.getElementById('style-selector').addEventListener('change', function (e) {
            const newStyle = e.target.value;
            changeMapStyle(newStyle);
        });

        map.on('draw.create', function (e) {
            e.features.forEach(handleFeature);
        });

        map.on('draw.update', function (e) {
            e.features.forEach(handleFeature);
        });

        map.on('draw.delete', function (e) {
            e.features.forEach(feature => {
                const marker = markers.get(feature.id);
                if (marker) {
                    marker.remove();
                    markers.delete(feature.id);
                }
            });
        });
    </script>
</body>

</html>